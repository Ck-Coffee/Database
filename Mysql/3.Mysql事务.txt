事务

1.	事务的四大特性（ACID）：
a.原子性：要么都发生，要么都不发生。
b.一致性：执行之前与执行之后的状态应该是一致的，类比转账业务。
c.隔离性：事务之间不能被相互干扰，稍后会讲到隔离级别。
d.持久性：一旦提交，对数据的改变是永久的。
	2. 	MySQL的隔离级别及相关问题：
			① Serializable (序列化)：可避免脏读、不可重复读、幻读的发生。
　　		② Repeatable read (可重复读)：可避免脏读、不可重复读的发生。
　　		③ Read committed (读已提交)：可避免脏读的发生。
　　		④ Read uncommitted (读未提交)：最低级别，任何情况都无法保证。
		丢失更新 ：当两个事务同时选择一行，如果都基于初值更改，那么最后的更新覆盖了由其他事务做的更新，对于其他事务而言，它们的更新都是无效的。
	脏读：顾名思义，就是读到了错误的数据，而之所以会读到错误的数据，是因为对数据的操作在各个事务之间是透明的，在事务A里可能会读到事务B正在修改
	但未提交的数据，一旦事务B再次修改该数据时，刚才事务A读到的数据就变成了脏数据。
		不可重复读：它与脏读唯一的区别就是，脏读是读未提交的数据，不可重复读是读已提交的数据，而并不是脏数据。它同样会造成在一个事务范围多次查询却
	得到不同的返回值。
		幻读：比如当事务A刚完成了对某一类数据的修改，事务B又插入一条该类数据，当事务A检查自己刚修改的表时，突然发现又多了一条该类数据未修改，仿佛出现
	了幻觉所以称为幻读。

		通过上面的四个问题，可以很轻易的看出，不同的隔离级别可以防止不同问题的产生，例如Read uncommitted (读未提交)显然无法避免以上三种问题的发生，
	而Read committed (读已提交)虽然能避免脏读，但是有不可重复读的问题，照样使其满足不了绝大多数业务。所以，Repeatable read (可重复读)应运而生，
	它表示当一个事务开启后，就不再允许其他事务对该事务数据进行修改操作，但可进行插入操作。故又会产生幻读的情况，这时就会出现Serializable (序列化)，
	它使事务之间只能串行化的执行，所以能避免这三类问题。最后提一句，大多数据库的默认隔离级别为Read committed，而MySQL的默认隔离级别是Repeatable read。

3.事务的死锁与避免：
		①锁粒度：
			行级锁：粒度最小，发生锁资源争用的概率最小，但是由于锁的粒度很小，每次加锁和释放锁都得做更多的事情，因此开销也会更大，更容易发生死锁。
			表级锁：逻辑简单，加锁带来的负面影响最小，所以每次获取锁和释放锁都很快，再加上每次都是对整张表进行加锁，所以能很好的避免死锁，但并发度低。
			页级锁：介于表锁和行锁之间，加锁和释放锁的开销也介于两者之间，提供的并发能力也介于两者之间，并且同样会产生死锁的问题。
			以上几种锁不能定论的说，哪种锁就最好；只能从锁的角度来说：表级锁更适合以查询为主，只有少量按索引条件更新少量数据的应用；行级锁则更适合于
		大量按索引条件并发更新少量不同数据，同时又有并发查询的应用。

		②MVCC(多版本控制)：不用加锁，而是通过一定的机制生成一个数据请求时间点的一致性数据快照，并利用这个快照来提供一定级别的一致性读取。
        从用户角度来看，好像数据库可以提供数据库的多个版本一样，因此称为多版本控制。
		从上面的介绍可以知道，死锁就是事务所需的锁被其他事务占有，从而形成死循环，造成死锁。
		所以，我们看下怎么避免死锁：
			*尽量约定以相同的顺序来访问表。
			*批量处理数据时，若事先排序，保证每个线程按固定的顺序处理记录。
			*尽量直接申请足够级别的锁。
			*尽量使用较低的隔离级别。
			*选择合理的事务大小。
			*尽量使用相等条件访问数据，避免Next-key对并发插入的影响。
